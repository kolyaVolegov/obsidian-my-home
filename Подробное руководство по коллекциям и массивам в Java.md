---
aliases:
  - Массивы
tags:
  - Методички
comment: 10й модуль. Массивы и списки
deadline: 2025-09-07
priority:
---

#Методички 
- **Введение в коллекции Java**Java Collections Framework
- Основные интерфейсы коллекций
- **Массивы в Java**Объявление и #инициализация
- Доступ к элементам и длина
- Итерация
- Многомерные массивы
- Операции с массивами (вставка, удаление, поиск, сортировка, копирование, заполнение)
- **Интерфейс List и его реализации**ArrayList: особенности, производительность, операции
- LinkedList: особенности, производительность, операции
- Сравнение ArrayList и LinkedList
- **Интерфейс Set и его реализации**HashSet: особенности, использование hashCode() и equals(), отсутствие дубликатов
- LinkedHashSet: сохранение порядка вставки
- TreeSet: упорядоченное хранение, использование Comparable и Comparator
- **Интерфейс Map и его реализации**HashMap: пары ключ-значение, производительность, null-ключи/значения
- LinkedHashMap: сохранение порядка вставки
- TreeMap: упорядоченное хранение по ключам
- **Интерфейс Queue и Deque и их реализации**Queue: FIFO принцип
- Deque: FIFO и LIFO, ArrayDeque
- PriorityQueue: упорядоченная очередь
- **Дженерики (Generics)**Назначение и преимущества
- Пример использования с коллекциями
- **Общие концепции и полезные методы**Потокобезопасность и синхронизация (Collections.synchronizedList, CopyOnWriteArrayList)
- Fail-fast и ConcurrentModificationException
- Методы вспомогательного класса Collections (sort, shuffle, reverse, rotate, swap, replaceAll, copy, fill)
- Методы вспомогательного класса Arrays (toString, copyOf, copyOfRange, sort, binarySearch, fill, equals)
- Когда использовать ArrayList vs. LinkedList vs. HashSet vs. HashMap

## 1. Введение в коллекции Java

### Java Collections Framework

Java Collections Framework (JCF) – это набор классов и интерфейсов в Java, предназначенный для представления и манипулирования коллекциями объектов. Он включает в себя интерфейсы для различных типов коллекций (таких как списки, множества, очереди, карты), их конкретные реализации и утилитарные классы для выполнения общих операций, таких как сортировка и поиск. JCF стандартизирует способ обработки коллекций, делая код более удобным и эффективным.

### Основные интерфейсы коллекций

- **Collection**: Базовый интерфейс в иерархии, определяющий общие методы для работы с группами элементов (например, add(), remove(), size(), isEmpty(), contains()). От него наследуются List, Set, Queue. Map не наследуется от Collection, но является частью JCF.
- **List**: Упорядоченная коллекция, позволяющая хранить дубликаты. Элементы доступны по индексу.
- **Set**: Коллекция, содержащая только уникальные элементы. Порядок элементов не гарантирован (зависит от реализации).
- **Queue**: Коллекция, разработанная для хранения элементов, предназначенных для обработки. Реализует принцип FIFO (First-In, First-Out).
- **Deque**: Расширение Queue, поддерживающее вставку и удаление элементов как с начала, так и с конца, то есть может работать как FIFO-очередь или LIFO-стек.
- **Map**: Коллекция, которая хранит пары "ключ-значение". Ключи должны быть уникальными, а значения могут повторяться. Позволяет искать значения по ключу.

## 2. Массивы в Java

Массив – это структура данных, которая хранит упорядоченную коллекцию элементов одного типа фиксированного размера.

### Объявление и инициализация

- **Объявление**: dataType[] arrayRefVar; или dataType arrayRefVar[]; (первый стиль предпочтительнее).
- **Создание (выделение памяти)**: arrayRefVar = new dataType[arraySize];. При создании элементы инициализируются значениями по умолчанию (0 для чисел, \0 для char, false для boolean, null для объектов).
- **Инициализация при объявлении**:
- int[] nums = new int[4]; (с значениями по умолчанию)
- int[] nums = new int[] { 1, 2, 3, 5 }; (с заданными значениями, размер определяется автоматически)
- int[] nums = { 1, 2, 3, 5 }; (сокращенная форма)

### Доступ к элементам и длина

- **Доступ**: Элементы массива доступны по индексу, который начинается с 0. Например, arrayName[index].
- **Длина**: Свойство length возвращает количество элементов в массиве. Например, arrayName.length. Размер массива не может быть изменен после создания.

### Итерация

- **Стандартный for цикл**: Используется для доступа к элементам по индексу, что позволяет изменять элементы или использовать их индексы.
- for (int i = 0; i < array.length; i++) {
- System.out.println(array[i]);
- }
- **for-each цикл (расширенный for)**: Предоставляет удобный способ перебора каждого элемента в массиве, но не дает доступа к индексу и не позволяет изменять элементы напрямую.
- for (int element : array) {
- System.out.println(element);
- }

### Многомерные массивы

Массивы могут быть многомерными, представляя собой "массивы массивов".

- **Объявление**: int[][] mas = new int[3][4]; (двумерный массив 3x4).
- **Доступ**: mas[row][column].
- **Зубчатые массивы**: В Java внутренние массивы в многомерном массиве могут иметь разную длину. Например, int[][] nums = new int[3][]; nums[0] = new int[2];.

### Операции с массивами (вставка, удаление, поиск, сортировка, копирование, заполнение)

- **Вставка (ручная)**: Требует сдвига элементов для освобождения места, что может быть неэффективно.
- **Удаление (ручное)**: Требует сдвига оставшихся элементов для заполнения пробела.
- **Класс java.util.Arrays**: Предоставляет статические методы для удобной работы с массивами:
- toString(): Преобразует массив в строковое представление.
- copyOf(): Копирует указанный массив.
- copyOfRange(): Копирует указанный диапазон массива.
- sort(): Сортирует элементы массива (для примитивных типов или объектов, реализующих Comparable, или с помощью Comparator).
- binarySearch(): Выполняет бинарный поиск в отсортированном массиве.
- fill(): Заполняет все или часть элементов массива заданным значением.
- equals(): Проверяет, равны ли два массива (по длине и по элементам).
- System.arraycopy(): Нативный метод для эффективного копирования частей массива.

## 3. Интерфейс List и его реализации

List — это упорядоченная коллекция, которая может содержать дубликаты и обеспечивает доступ к элементам по индексу.

### ArrayList: особенности, производительность, операции

- **Особенности**: Реализация List на основе динамически масштабируемого массива. Поддерживает null элементы. Сохраняет порядок вставки.
- **Производительность**:
- Произвольный доступ по индексу (get, set): $O(1)$ (константное время).
- Добавление элемента в конец (add): Амортизированное константное время $O(1)$. Если массив заполнен, происходит расширение (копирование всех элементов в новый, больший массив), что занимает $O(n)$ время.
- Вставка/удаление из середины: $O(n)$ (линейное время), так как требует сдвига всех последующих элементов с использованием System.arraycopy().
- Поиск по значению (indexOf, contains): $O(n)$ (линейное время) для несортированного списка.
- **Операции**: add(), get(), set(), remove(), size(), isEmpty(), indexOf(), contains(), clear(), addAll(), toArray(), trimToSize().

### LinkedList: особенности, производительность, операции

- **Особенности**: Реализует как List, так и Deque. Основан на двунаправленном связном списке, где каждый элемент содержит ссылки на предыдущий и следующий элементы. Поддерживает null элементы. Сохраняет порядок вставки.
- **Производительность**:
- Добавление/удаление из начала/конца (addFirst, addLast, removeFirst, removeLast): $O(1)$ (константное время).
- Вставка/удаление из середины (с известным итератором): $O(1)$.
- Доступ по индексу (get, set) или поиск по значению (indexOf, contains): $O(n)$ (линейное время), так как требует обхода списка от начала или конца до нужного элемента.
- **Операции**: В дополнение к методам List, включает методы Deque типа addFirst(), addLast(), removeFirst(), removeLast().

### Сравнение ArrayList и LinkedList

- **ArrayList** лучше подходит, когда требуется частый произвольный доступ к элементам по индексу и меньше операций вставки/удаления из середины.
- **LinkedList** предпочтительнее, когда часты операции добавления/удаления элементов с произвольными индексами (если у вас есть итератор, указывающий на позицию) или из начала/конца списка, а произвольный доступ по индексу встречается реже.

## 4. Интерфейс Set и его реализации

Set — это коллекция, которая не содержит дублирующихся элементов.

### HashSet: особенности, использование hashCode() и equals(), отсутствие дубликатов

- **Особенности**: Реализация Set, основанная на хеш-таблице (внутренне использует HashMap). Не гарантирует порядок элементов. Поддерживает null элемент.
- **Дубликаты**: Set не допускает дубликатов. При добавлении нового элемента HashSet использует методы hashCode() и equals() для определения уникальности. Если hashCode() одинаков, затем equals() используется для сравнения объектов. Если equals() возвращает true, элемент считается дубликатом и не добавляется.
- **Производительность**: Операции add(), remove(), contains(), size() выполняются за константное время $O(1)$ в среднем, при условии хорошей хеш-функции. В худшем случае (много коллизий) может быть $O(n)$.
- **Важность hashCode() и equals()**: Корректная реализация этих методов критична для правильной работы HashSet с пользовательскими объектами. Без переопределения используются реализации из класса Object, которые сравнивают объекты по адресу памяти, что может привести к хранению "дубликатов" по значению.

### LinkedHashSet: сохранение порядка вставки

- **Особенности**: Расширяет HashSet, добавляя двунаправленный связный список, который поддерживает порядок элементов в том порядке, в каком они были вставлены.
- **Производительность**: Немного медленнее HashSet из-за поддержания связного списка, но все еще имеет амортизированную константную производительность для основных операций.

### TreeSet: упорядоченное хранение, использование Comparable и Comparator

- **Особенности**: Реализация Set, основанная на красно-чёрном дереве (внутренне использует TreeMap). Хранит элементы в отсортированном порядке (по "естественному" порядку элементов или с использованием предоставленного Comparator). Не допускает null элементы, если используется естественный порядок или Comparator, не поддерживающий null.
- **Производительность**: Операции add(), remove(), contains() выполняются за время $O(\log n)$ (логарифмическое время).
- **Сортировка**:
- **Natural Ordering**: Если элементы реализуют интерфейс Comparable, TreeSet будет сортировать их согласно их естественному порядку (compareTo() метод).
- **Custom Ordering**: Можно предоставить объект Comparator при создании TreeSet, чтобы определить пользовательский порядок сортировки.

## 5. Интерфейс Map и его реализации

Map — это объект, который сопоставляет ключи со значениями. Не может содержать дубликаты ключей; каждый ключ может быть связан не более чем с одним значением.

### HashMap: пары ключ-значение, производительность, null-ключи/значения

- **Особенности**: Реализация Map на основе хеш-таблицы. Не гарантирует порядок элементов. Разрешает один null ключ и множество null значений.
- **Производительность**: Операции get() и put() выполняются за константное время $O(1)$ в среднем, при условии хорошей хеш-функции. Итерация по элементам занимает время, пропорциональное "емкости" HashMap плюс его размер.
- **Load Factor и Capacity**: Влияют на производительность. Load Factor (по умолчанию 0.75) определяет, насколько полной может быть хеш-таблица до автоматического увеличения ее размера (rehashing), что является дорогой операцией $O(n)$.

### LinkedHashMap: сохранение порядка вставки

- **Особенности**: Расширяет HashMap, поддерживая порядок итерации элементов в порядке их добавления (или по порядку доступа, если настроено). Достигается это за счет двунаправленных связей между элементами.
- **Производительность**: Имеет накладные расходы на память из-за поддержания связного списка, но сохраняет производительность HashMap для основных операций.

### TreeMap: упорядоченное хранение по ключам

- **Особенности**: Реализация Map на основе красно-чёрного дерева. Элементы хранятся в отсортированном порядке по ключам (естественный порядок или Comparator). Не допускает null ключи.
- **Производительность**: Операции put(), get(), remove() выполняются за логарифмическое время $O(\log n)$.

## 6. Интерфейс Queue и Deque и их реализации

### Queue: FIFO принцип

- **Особенности**: Представляет собой коллекцию, предназначенную для хранения элементов до их обработки. Основной принцип — FIFO (First-In, First-Out), то есть элемент, добавленный первым, будет удален первым.
- **Методы**: add(), offer() (добавляют), remove(), poll() (удаляют), element(), peek() (просматривают). Методы с offer/poll/peek предпочтительнее, так как они возвращают null или false в случае неудачи, в отличие от add/remove/element, которые выбрасывают исключения.

### Deque: FIFO и LIFO, ArrayDeque

- **Особенности**: Расширяет интерфейс Queue и позволяет выполнять операции как с начала, так и с конца коллекции, тем самым реализуя поведение очереди (FIFO) и стека (LIFO - Last-In, First-Out).
- **ArrayDeque**: Эффективная реализация Deque на основе изменяемого массива. Работает быстрее, чем Stack (для LIFO) и LinkedList (для FIFO). Не поддерживает null элементы.

### PriorityQueue: упорядоченная очередь

- **Особенности**: Реализация Queue, которая упорядочивает элементы согласно их естественному порядку или с использованием предоставленного Comparator. Элемент с наивысшим приоритетом (наименьший по значению) всегда находится в начале очереди. Не допускает null элементы.
- **Производительность**: Операции добавления и удаления имеют логарифмическое время $O(\log n)$.

## 7. Дженерики (Generics)

Дженерики были добавлены в Java 5 (Tiger) для повышения безопасности типов во время компиляции и уменьшения необходимости в приведениях типов.

- **Назначение и преимущества**:
- **Безопасность типов**: Позволяют указать тип элементов, которые могут храниться в коллекции, во время ее создания. Компилятор обнаруживает ошибки несоответствия типов, предотвращая ClassCastException во время выполнения.
- **Устранение приведений типов**: Больше нет необходимости вручную приводить извлекаемые элементы к их исходному типу, так как компилятор знает тип.
- **Повторное использование кода**: Позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных, сохраняя при этом типобезопасность.
- **Пример использования с коллекциями**:
- // До Java 5 (без дженериков)
- ArrayList list = new ArrayList();
- list.add("строка");
- list.add(123); // Можно добавить любой объект
- String s = (String) list.get(0); // Требуется приведение типа
- Integer i = (Integer) list.get(1); // Требуется приведение типа

- // С Java 5 (с дженериками)
- ArrayList<String> stringList = new ArrayList<>(); // Использование "diamond operator" с Java 7
- stringList.add("строка");
- // stringList.add(123); // Ошибка компиляции! Повышенная безопасность типов
- String s = stringList.get(0); // Не требуется приведение типа

## 8. Общие концепции и полезные методы

### Потокобезопасность и синхронизация

- Большинство реализаций коллекций в java.util (например, ArrayList, HashMap, HashSet, TreeSet) **не синхронизированы** (не потокобезопасны). Если несколько потоков одновременно обращаются к экземпляру коллекции и хотя бы один из них структурно модифицирует ее, требуется внешняя синхронизация.
- **Collections.synchronizedList() / Collections.synchronizedMap() / Collections.synchronizedSet()**: Методы-обертки, предоставляемые классом Collections, которые возвращают синхронизированную (потокобезопасную) версию существующей коллекции. Рекомендуется использовать их во время создания коллекции, чтобы избежать случайного несинхронизированного доступа.
- **CopyOnWriteArrayList**: (Добавлен в Java 5) Потокобезопасный вариант ArrayList, оптимизированный для сценариев, где чтение значительно превосходит запись. Все мутативные операции (добавление, установка и т.д.) реализуются путем создания новой копии базового массива.

### Fail-fast и ConcurrentModificationException

- Итераторы, возвращаемые большинством коллекций (ArrayList, HashMap, HashSet, LinkedList, TreeSet), являются "fail-fast".
- Это означает, что если коллекция структурно модифицируется после создания итератора любым способом, кроме как через собственные методы remove() или add() итератора, итератор выбросит ConcurrentModificationException.
- Поведение "fail-fast" предназначено для **обнаружения ошибок** в коде, а не для корректного поведения при одновременных модификациях. Его нельзя гарантировать при несогласованных одновременных модификациях.

### Методы вспомогательного класса Collections (java.util.Collections)

Это утилитарный класс, предоставляющий статические методы для работы с коллекциями (сортировка, поиск, перемешивание и т.д.).

- sort(List list): Сортирует список в естественном порядке.
- sort(List list, Comparator c): Сортирует список с использованием пользовательского компаратора.
- shuffle(List list): Случайным образом переставляет элементы в списке.
- reverse(List list): Меняет порядок элементов в списке на обратный.
- rotate(List list, int distance): "Проворачивает" элементы в списке на указанное расстояние.
- swap(List list, int i, int j): Меняет местами элементы по указанным индексам.
- replaceAll(List list, Object oldVal, Object newVal): Заменяет все вхождения oldVal на newVal.
- copy(List dest, List src): Копирует все элементы из src в dest. dest должен иметь достаточный размер.
- fill(List list, Object obj): Заполняет весь список указанным объектом.

### Методы вспомогательного класса Arrays (java.util.Arrays)

Этот класс содержит статические методы для выполнения общих операций с массивами.

- toString(array): Возвращает строковое представление содержимого массива.
- copyOf(original, newLength): Копирует указанный массив, усекая или дополняя нулями при необходимости.
- copyOfRange(original, from, to): Копирует указанный диапазон массива.
- sort(array): Сортирует указанный массив.
- binarySearch(array, key): Ищет указанное значение в отсортированном массиве, используя алгоритм двоичного поиска.
- fill(array, val): Присваивает указанное значение каждому элементу массива.
- equals(array1, array2): Возвращает true, если два массива равны (одинаковая длина и одинаковые элементы в том же порядке).

### Когда использовать...?

- **ArrayList**: Если нужен динамический массив, частый доступ по индексу, и мало операций вставки/удаления из середины.
- **LinkedList**: Если нужны частые вставки/удаления из начала/конца или из середины (с итератором), и меньше операций произвольного доступа по индексу. Также подходит для реализации очередей/стеков.
- **HashSet**: Если нужны уникальные элементы и порядок не важен, а важен быстрый поиск.
- **LinkedHashSet**: Как HashSet, но с сохранением порядка вставки.
- **TreeSet**: Если нужны уникальные элементы, которые должны быть отсортированы.
- **HashMap**: Если нужны пары "ключ-значение" и важен быстрый поиск по ключу, а порядок не важен.
- **LinkedHashMap**: Как HashMap, но с сохранением порядка вставки ключей.
- **TreeMap**: Если нужны пары "ключ-значение", отсортированные по ключу.
- **ArrayDeque**: Для эффективной реализации стека или двусторонней очереди.
- **PriorityQueue**: Если элементы в очереди должны быть отсортированы по приоритету.

## Тест: 10 коротких вопросов

Ответьте на каждый вопрос в 2-3 предложениях.

1. Каково основное отличие между ArrayList и обычным массивом в Java?
2. Объясните концепцию "fail-fast" и ConcurrentModificationException в контексте итераторов коллекций Java.
3. В чем разница в производительности между ArrayList и LinkedList при вставке элемента в середину списка?
4. Почему HashSet требует, чтобы пользовательские объекты корректно переопределяли методы hashCode() и equals()?
5. Какой интерфейс коллекций Java гарантирует отсутствие дубликатов, но не порядок элементов? Назовите одну его реализацию.
6. Объясните принцип FIFO, применяемый в Queue.
7. В каких реализациях коллекций Java не допускаются null-элементы и почему?
8. Как дженерики повышают безопасность типов при работе с коллекциями в Java?
9. Когда следует использовать Collections.synchronizedList() вместо стандартных несинхронизированных коллекций?
10. Какой метод класса java.util.Arrays используется для преобразования массива в строковое представление? Приведите пример.

## Ключ к тесту

1. ArrayList – это динамически масштабируемый массив, который может автоматически изменять свой размер при добавлении или удалении элементов. В отличие от этого, обычный массив в Java имеет фиксированный размер, который нельзя изменить после его создания. Это делает ArrayList более гибким для работы с коллекциями переменного размера.
2. "Fail-fast" относится к поведению итераторов коллекций, которые немедленно выбрасывают ConcurrentModificationException, если обнаруживают структурную модификацию коллекции (добавление/удаление элементов) во время итерации, выполненную не через методы самого итератора. Это помогает обнаружить потенциальные ошибки параллельного доступа к коллекции.
3. При вставке элемента в середину списка ArrayList требует сдвига всех последующих элементов, что приводит к линейной временной сложности $O(n)$. LinkedList, благодаря своей структуре двунаправленного связного списка, может вставить элемент в середину за константное время $O(1)$, если уже есть ссылка на позицию вставки.
4. HashSet использует методы hashCode() и equals() для определения уникальности элементов и их размещения в хеш-таблице. Если эти методы не переопределены для пользовательских объектов, HashSet может ошибочно хранить несколько объектов, которые логически считаются одинаковыми (по значению), поскольку он будет сравнивать их по ссылкам/адресам памяти.
5. Интерфейс Set гарантирует отсутствие дубликатов, но не определяет порядок элементов. Одной из его реализаций является HashSet.
6. Принцип FIFO (First-In, First-Out) означает, что элемент, который был первым добавлен в очередь, будет также первым извлечен из нее. Это похоже на обычную очередь в реальной жизни: кто пришел первым, того и обслуживают первым.
7. null-элементы не допускаются в TreeMap и TreeSet, потому что эти структуры упорядочивают элементы, и null не может быть корректно сравнен с другими объектами для определения порядка. Также ArrayDeque не допускает null как элемент, так как использует null как специальное значение для индикации пустоты.
8. Дженерики позволяют программисту указать тип элементов, которые будут храниться в коллекции, во время компиляции. Это позволяет компилятору проверять соответствие типов, предотвращая ошибки ClassCastException во время выполнения и устраняя необходимость в явных приведениях типов.
9. Collections.synchronizedList() следует использовать, когда необходимо работать с ArrayList (или другими коллекциями) в многопоточной среде, и несколько потоков могут одновременно структурно изменять список. Оборачивание списка в синхронизированную версию при его создании гарантирует потокобезопасность операций с ним.
10. Метод java.util.Arrays.toString() используется для преобразования массива в его строковое представление. Например, int[] nums = {1, 2, 3}; System.out.println(Arrays.toString(nums)); выведет [1, 2, 3].

## 5 вопросов эссе-формата

1. Подробно сравните и противопоставьте ArrayList и LinkedList в Java, уделяя особое внимание их внутренней реализации, временной сложности различных операций (добавление, удаление, доступ по индексу, итерация) и сценариям использования, когда один тип предпочтительнее другого.
2. Объясните роль hashCode() и equals() методов при работе с коллекциями Set и Map в Java. Продемонстрируйте, как некорректная реализация этих методов может привести к нежелательному поведению (например, появлению дубликатов в HashSet или неспособности найти элемент в HashMap), и предложите рекомендации по их правильному переопределению.
3. Опишите, как дженерики изменили работу с Java Collections Framework. Какие проблемы они решили, и какие новые концепции (например, оператор diamond) появились благодаря им? Приведите примеры кода, демонстрирующие использование дженериков до и после Java 7.
4. Сравните HashSet, LinkedHashSet и TreeSet с точки зрения их внутренней структуры данных, гарантий порядка элементов и производительности для основных операций (add, remove, contains). В каких случаях и почему разработчик выбрал бы одну из этих реализаций над другими?
5. Обсудите концепции потокобезопасности и "fail-fast" в контексте Java Collections Framework. Объясните, почему большинство стандартных коллекций не являются потокобезопасными, и какие механизмы (например, Collections.synchronizedList, CopyOnWriteArrayList) предоставляются для работы с коллекциями в многопоточной среде. Также подробно рассмотрите, для чего служит "fail-fast" поведение и почему на него нельзя полагаться для обеспечения корректности.

## Глоссарий ключевых терминов

- **ArrayList**: Динамически масштабируемая реализация интерфейса List, основанная на массиве.
- **ArrayDeque**: Реализация интерфейса Deque на основе изменяемого массива, эффективно работающая как очередь и как стек.
- **Базисный массив (Backing Array)**: Внутренний массив, который ArrayList использует для хранения своих элементов.
- **Бакет (Bucket)**: В хеш-таблице, это "корзина" или ячейка, куда помещаются элементы с одинаковым или близким хеш-кодом.
- **Временная сложность (Time Complexity)**: Мера того, как время выполнения алгоритма или операции растет с увеличением размера входных данных (например, $O(1)$, $O(n)$, $O(\log n)$).
- **Дженерики (Generics)**: Возможность в Java указывать тип элементов, которые будут храниться в коллекции, обеспечивая безопасность типов во время компиляции.
- **Двунаправленный связный список (Doubly Linked List)**: Структура данных, где каждый узел содержит ссылки как на следующий, так и на предыдущий узел. Используется в LinkedList.
- **Deque (Double-Ended Queue)**: Интерфейс коллекции, который позволяет добавлять и удалять элементы как с начала, так и с конца.
- **Fail-fast (Быстрый отказ)**: Поведение итератора, который выбрасывает ConcurrentModificationException, если коллекция была структурно изменена во время итерации внешним образом.
- **FIFO (First-In, First-Out)**: Принцип "первым пришел – первым ушел", характерный для очередей.
- **HashMap**: Реализация интерфейса Map на основе хеш-таблицы, не гарантирующая порядок элементов.
- **HashSet**: Реализация интерфейса Set на основе хеш-таблицы, хранящая уникальные элементы без гарантированного порядка.
- **Хеш-код (Hash Code)**: Целочисленное значение, возвращаемое методом hashCode(), используемое хеш-таблицами для эффективного распределения и поиска элементов.
- **Хеш-таблица (Hash Table)**: Структура данных, которая отображает ключи на значения с использованием хеш-функции для быстрого поиска.
- **Итератор (Iterator)**: Объект, который позволяет последовательно обходить элементы коллекции.
- **Java Collections Framework (JCF)**: Набор классов и интерфейсов в Java для работы с коллекциями объектов.
- **Comparable**: Интерфейс, который объект реализует, чтобы определить "естественный" порядок сортировки для себя.
- **Comparator**: Интерфейс, который позволяет определить пользовательский порядок сортировки для объектов, не изменяя их класс.
- **Константное время (Constant Time)**: Обозначается $O(1)$, означает, что время выполнения операции не зависит от размера входных данных.
- **Коллекция (Collection)**: Общий интерфейс, представляющий группу объектов.
- **Коллизия (Collision)**: Ситуация в хеш-таблице, когда два разных ключа генерируют один и тот же хеш-код или индекс бакета.
- **CopyOnWriteArrayList**: Потокобезопасная реализация List, которая создает новую копию базового массива при каждой мутативной операции.
- **LIFO (Last-In, First-Out)**: Принцип "последним пришел – первым ушел", характерный для стеков.
- **Линейное время (Linear Time)**: Обозначается $O(n)$, означает, что время выполнения операции прямо пропорционально размеру входных данных.
- **LinkedHashMap**: Расширение HashMap, которое сохраняет порядок вставки (или порядок доступа).
- **LinkedHashSet**: Расширение HashSet, которое сохраняет порядок вставки элементов.
- **LinkedList**: Реализация интерфейса List и Deque на основе двунаправленного связного списка.
- **ListIterator**: Расширение Iterator, позволяющее обходить список в обоих направлениях и модифицировать его во время итерации.
- **Load Factor (Коэффициент загрузки)**: Параметр в хеш-таблицах, определяющий, насколько полным может быть массив до того, как его размер будет увеличен (перехеширование).
- **Логарифмическое время (Logarithmic Time)**: Обозначается $O(\log n)$, означает, что время выполнения операции растет логарифмически с увеличением размера входных данных (характерно для операций в древовидных структурах).
- **Map**: Интерфейс, хранящий пары "ключ-значение", где ключи уникальны.
- **Множество (Set)**: Коллекция, которая не содержит дубликатов.
- **Null-элементы**: Значения null (отсутствие объекта), которые могут или не могут быть разрешены в различных коллекциях.
- **Оператор Diamond (Diamond Operator)**: () – сокращенный синтаксис для создания экземпляров дженерик-классов, представленный в Java 7, который позволяет компилятору выводить тип.
- **Очередь (Queue)**: Интерфейс коллекции, реализующий принцип FIFO.
- **Потокобезопасность (Thread-Safety)**: Способность кода безопасно работать при одновременном доступе из нескольких потоков.
- **PriorityQueue**: Реализация интерфейса Queue, которая упорядочивает элементы по их приоритету.
- **Расширение массива (Resizing)**: Процесс создания нового, большего базового массива и копирования в него всех элементов при заполнении текущего массива в ArrayList.
- **Синхронизация (Synchronization)**: Механизм в Java для контроля доступа к общим ресурсам в многопоточной среде, чтобы предотвратить состояния гонки.
- **Список (List)**: Упорядоченная коллекция, которая может содержать дубликаты.
- **Структурная модификация (Structural Modification)**: Любая операция, которая изменяет размер коллекции или существенно влияет на ее внутреннюю структуру (например, добавление или удаление элементов).
- **TreeMap**: Реализация интерфейса Map на основе красно-чёрного дерева, хранящая пары "ключ-значение" в отсортированном порядке по ключам.
- **TreeSet**: Реализация интерфейса Set на основе красно-чёрного дерева, хранящая уникальные и отсортированные элементы.
- **Упорядоченный (Ordered)**: Коллекция, которая сохраняет порядок элементов (например, порядок вставки или естественный/пользовательский порядок сортировки).